Коллега, это превосходный и очень важный вопрос. Использование set -euo pipefail — это признак профессионального подхода к написанию скриптов, но, как вы верно заметили, по умолчанию эта мощная конструкция может быть "немой". Когда скрипт просто молча прекращает работу, это крайне затрудняет отладку.
К счастью, в Bash есть встроенные механизмы, чтобы точно узнать, что, где и почему пошло не так. Давайте рассмотрим их, от простого к самому надежному.
Метод 1: Простой, но Мощный — trap с Переменными Окружения Bash
Это самый распространенный и эффективный метод, который я рекомендую использовать во всех ваших скриптах. Мы установим "ловушку" (trap), которая сработает в момент завершения скрипта с ошибкой и выведет всю необходимую отладочную информацию.
Добавьте этот блок сразу после строки set -euo pipefail:
Generated bash
#!/bin.bash

set -euo pipefail

# --- НАЧАЛО БЛОКА ОТЛАДКИ ---
# Устанавливаем ловушку на сигнал ERR (любая ошибка, которая приводит к выходу из-за 'set -e')
# и на сигнал EXIT (любой выход из скрипта).
trap 'catch $? $LINENO' ERR
trap 'cleanup' EXIT # Ловушка для очистки при любом выходе

catch() {
  # Аргумент 1: код выхода последней команды ($?)
  # Аргумент 2: номер строки, где произошла ошибка ($LINENO)
  echo
  echo "================= ERROR =================="
  echo "ОШИБКА: Код выхода '$1' в строке '$2'"
  echo "Команда, вызвавшая ошибку:"
  # BASH_COMMAND содержит последнюю выполненную команду
  echo "    $BASH_COMMAND"
  echo "=========================================="
  echo
}

cleanup() {
  # Здесь можно разместить код для очистки временных файлов,
  # отключения от баз данных и т.д.
  # trap -r ERR # Можно убрать ловушку на ошибку, чтобы избежать двойного срабатывания
  echo "Скрипт завершен."
}
# --- КОНЕЦ БЛОКА ОТЛАДКИ ---


# ... ДАЛЬШЕ ИДЕТ ВАШ ОБЫЧНЫЙ КОД ...

echo "Начинаю работу..."
ls /nonexistent_directory # Эта команда вызовет ошибку
echo "Этот текст никогда не будет выведен."
Use code with caution.
Bash
Как это работает:
trap 'catch $? $LINENO' ERR:
trap: Команда для установки ловушки.
'...': Действие, которое нужно выполнить, когда ловушка сработает.
ERR: Сигнал, на который мы ставим ловушку. ERR срабатывает каждый раз, когда команда завершается с ненулевым кодом выхода, что при set -e приводит к завершению скрипта.
catch $? $LINENO: Мы вызываем нашу собственную функцию catch и передаем ей два "магических" аргумента:
$?: Это код выхода последней выполненной команды. 0 — успех, все остальное — ошибка.
$LINENO: Это номер текущей строки в скрипте. В момент срабатывания trap ERR, эта переменная содержит номер строки, где произошла ошибка.
Функция catch():
Она принимает код выхода и номер строки как аргументы ($1 и $2).
Она выводит эти данные в понятном формате.
Самое главное: Она использует еще одну встроенную переменную Bash — $BASH_COMMAND. Эта переменная всегда содержит текст последней команды, которая была выполнена. Это позволяет нам увидеть точную команду-виновника.
Результат выполнения скрипта выше будет таким:
Generated code
Начинаю работу...
ls: невозможно получить доступ к '/nonexistent_directory': Нет такого файла или каталога

================= ERROR ==================
ОШИБКА: Код выхода '2' в строке '32'
Команда, вызвавшая ошибку:
    ls /nonexistent_directory
==========================================

Скрипт завершен.
Use code with caution.
Вы получаете исчерпывающую информацию: что сломалось, где сломалось и какой был код ошибки.
Метод 2: Встроенная трассировка Bash (set -x)
Иногда вам нужно видеть не только место сбоя, а вообще всё, что делает скрипт. Для этого есть опция set -x. Она заставляет Bash печатать каждую команду перед ее выполнением.
Вы можете включать и выключать ее для конкретных участков кода.
Generated bash
#!/bin.bash

set -euo pipefail

echo "Этот участок выполняется в обычном режиме."
my_variable="secret"

echo "--- Включаю режим трассировки ---"
set -x

# Теперь каждая команда будет напечатана
dangerous_command="ls /nonexistent_directory"
echo "Собираюсь выполнить опасную команду..."
eval "$dangerous_command" # eval здесь для примера, обычно его стоит избегать

# Этот код не будет выполнен, но если бы был, трассировка бы выключилась
set +x
echo "--- Режим трассировки выключен ---"
Use code with caution.
Bash
Как это работает:
set -x: Включает режим трассировки. Bash будет выводить в stderr (стандартный поток ошибок) каждую команду, подставляя в нее значения переменных.
set +x: Выключает режим трассировки.
Результат выполнения будет таким:
Generated code
Этот участок выполняется в обычном режиме.
--- Включаю режим трассировки ---
+ dangerous_command='ls /nonexistent_directory'
+ echo 'Собираюсь выполнить опасную команду...'
Собираюсь выполнить опасную команду...
+ eval 'ls /nonexistent_directory'
++ ls /nonexistent_directory
ls: невозможно получить доступ к '/nonexistent_directory': Нет такого файла или каталога
Use code with caution.
Знак + показывает команды, которые выполняет set -x. Этот метод очень подробный и полезен для отладки сложных подстановок переменных и логики, но может создавать очень много "шума" в выводе.
Рекомендация для вас
Всегда используйте Метод 1 (trap). Добавьте этот блок отладки в начало каждого вашего скрипта как шаблон. Это обеспечит вас всей необходимой информацией при сбое, не засоряя вывод при успешном выполнении.
Используйте Метод 2 (set -x) временно, для отладки конкретного проблемного участка. Когда вы не понимаете, почему определенный блок кода ведет себя не так, как вы ожидаете, оберните его в set -x и set +x, чтобы увидеть всю "внутреннюю кухню". После отладки не забудьте убрать эти строки.