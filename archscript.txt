#!/bin/bash

exec > >(tee -a "outputarchauto.log") 2>&1
set -euo pipefail
#TODO Переписать редактирование json на утилиту jq
#TODO Пользовательские службы systemd требуют доступа к пользовательской сессии D-Bus. Скрипт пытается передать переменные DBUS_SESSION_BUS_ADDRESS и XDG_RUNTIME_DIR, но это не гарантирует успех. Если у пользователя нет активной графической сессии в момент запуска скрипта, D-Bus не будет доступен, и команда завершится ошибкой. Это крайне ненадежный метод.
# Проверка на root
#Установка Arch Linux
#TODO добавить функции вывода сообщений
# info() {
#     echo -e "\033[1;34m[INFO]\033[0m $1"
# }

# success() {
#     echo -e "\033[1;32m[SUCCESS]\033[0m $1"
# }

# warning() {
#     echo -e "\033[1;33m[WARNING]\033[0m $1"
# }
#Ограничение журнала
journalctl --vacuum-size=30M
journalctl --verify
systemctl restart systemd-journald

y="yes"
yay="yes"
file="/etc/systemd/journald.conf"
search_maxuse="SystemMaxUse"
search_max_file_size="SystemMaxFileSize"
new_value_maxuse="50M"
new_max_file_size="40M"
custom_sysctl="/etc/sysctl.d/99-custom.conf"
new_swappiness="10"
new_cash_pressure="65"
search_swappiness="vm.swappiness"
search_cash_pressure="vm.vfs_cache_pressure"
pacman_config="/etc/pacman.conf"
search_parallel_dow="ParallelDownloads"
new_parallel_dow="10"
user_nosudo="$SUDO_USER"
path_yay_cfg="/home/$user_nosudo/.config/yay/config.json"
srch_yay_config="cleanAfter"
yay_packages="yes"
trim="yes"
grab_conf="/etc/default/grub"
srch_grub_default="GRUB_CMDLINE_LINUX_DEFAULT"
grub_configurator="yes"

USER_RUNTIME_DIR="/run/user/$(id -u $user_nosudo)"

#$search_maxuse и так далее - переменные

#Проверка для создания бэкапа journal.conf
if [ -f "$file.original" ]; then
echo "Бэкап был уже ранее создан: $file.original"
else
#Проверка существования файла
if [ -f "$file" ]; then
#В квадратных скобках [] прописывается условие для проверки. Необходимы пробелы после и перед скобкаби (перед и после условия проверки)
# -f проверяет существует ли файл с именем, указанным справа
#Создание бэкапа
cp "$file" "$file.original"
echo "Был создан бэкап: $file.original"
else
echo "Файл не найден: $file"
fi
fi
#Для каждого if нужен свой fi

#замена SystemMaxUse
if grep -q "^#$search_maxuse" "$file"; then
#grep - команда поиска текста в файле
#-q - тихий режим, grep не выводит строки, а просто сообщает о найденом совпадении

sed -i "s/^#$search_maxuse=.*/$search_maxuse=$new_value_maxuse/" "$file"
#sed -i Редактирует файл на месте
#"s" -команда замены для sed
# s/шаблон/замена/
#/^ - обозначение начала строки для поиска. В замене он обозначается буквально
# .* - регулярное выражение, которое обозначает любое выражение до перевода строки
echo "#$search_maxuse был заменен"
else
if grep -q "^$search_maxuse=" "$file"; then
sed -i "s/^$search_maxuse=.*/$search_maxuse=$new_value_maxuse/" "$file"
echo "*^$search_maxuse был заменен"
else
echo "$search_maxuse=$new_value_maxuse" >> "$file"
echo "SystemMaxUse был добавлен в конец файла"
fi
fi

#SystemMaxFileSize замена
if grep -q "^#$search_max_file_size" "$file"; then

sed -i "s/^#$search_max_file_size=.*/$search_max_file_size=$new_max_file_size/" "$file"
#sed -i редактирвует в инлайне
#s/шаблон/замена/
#^-начало строки
#.*-регулряное выражение, обозанчающие любое выражение до перевода строки

echo "#$search_max_file_size был заменен на $search_max_file_size=$new_max_file_size"

else
if grep -q "^$search_max_file_size" "$file"; then
sed -i "s/^$search_max_file_size.*/$search_max_file_size=$new_max_file_size/" "$file"

echo "$search_max_file_size был заменен на $search_max_file_size=$new_max_file_size"

else

echo "$search_max_file_size=$new_max_file_size" >> "$file"
echo "$search_max_file_size=$new_max_file_size был добавлен в конце $file"
fi
fi


#Создание кастомного systemctl
if [ -f "$custom_sysctl" ]; then
echo "$custom_sysctl уже был ранее создан"
else

touch "$custom_sysctl"
echo "$custom_sysctl создан"
fi

#добавляем vm.swappiness в кастомный sysctl
if grep -q "^$search_swappiness" "$custom_sysctl"; then

sed -i "s/^$search_swappiness=.*/$search_swappiness=$new_swappiness/" "$custom_sysctl"

echo "$search_swappiness бы заменен на $new_swappiness"

else

echo "$search_swappiness=$new_swappiness" >> "$custom_sysctl"
echo "$search_swappiness=$new_swappiness был добавлен в конце $custom_sysctl"
fi

#добавляем vm.vfs_cache_pressure в sysctl
if grep -q "^$search_cash_pressure" "$custom_sysctl"; then

sed -i "s/^$search_cash_pressure=.*/$search_cash_pressure=$new_cash_pressure/" "$custom_sysctl"

echo "$search_cash_pressure бы заменен на $new_cash_pressure"

else

echo "$search_cash_pressure=$new_cash_pressure" >> "$custom_sysctl"
echo "$search_cash_pressure=$new_cash_pressure бы добавлен в конце $custom_sysctl"
fi

#sysctl --system

if grep -q "^$search_parallel_dow.*" "$pacman_config"; then

sed -i "s/^$search_parallel_dow.*/$search_parallel_dow = $new_parallel_dow/" "$pacman_config"

echo "$search_parallel_dow было заменено значение на $new_parallel_dow"

fi

if grep -q "^#Color" "$pacman_config"; then

sed -i "s/#Color/Color/" "$pacman_config"
echo "Color был включен"
else
if grep -q "^Color" "$pacman_config"; then

echo "Color уже включен"
else
echo "Color" >> "$pacman_config"

fi
fi

if grep -q "^ILoveCandy" "$pacman_config"; then
#! инвентирует условие
#-v -инвентирует условие. То есть если НЕ, то условие выполняется
echo "ILoveCandy уже включен"
else

sed -i "/^Color/a ILoveCandy" "$pacman_config"
#-i редактирует файл на месте
# a/ камманда append в sed, вставляет новую сроку, после найденной строки
#шаблон вставки: "/что ищем/a что вставляем" "$file"
fi

echo "Идет обновление системы"

pacman -Syu --noconfirm
echo "Обновление завершено"

echo "Идет установка пакетов"
if [ "$y" == "yes" ]; then
# Установка шрифтов 
pacman -S --needed --noconfirm ttf-dejavu noto-fonts noto-fonts-cjk noto-fonts-emoji ttf-liberation ttf-fira-code ttf-jetbrains-mono ttf-hack ttf-nerd-fonts-symbols noto-fonts-extra powerline-fonts nerd-fonts-hack
# Установка остальных пакетов
pacman -S --needed --noconfirm bash-completion bottom ripgrep xf86-video-ati flatpak mesa lib32-mesa vulkan-radeon lib32-vulkan-radeon base-devel gamemode plasma-sdk kio-extras lib32-gamemode chromium cpupower bat lsd duf dust gping openssh networkmanager git wget xdg-user-dirs pacman-contrib ntfs-3g timeshift apparmor ufw fail2ban libpwquality extra/linux-hardened-headers tor torbrowser-launcher nyx multilib/steam-native-runtime pavucontrol plasma-browser-integration gwenview filelight unrar zip power-profiles-daemon fastfetch terminator code
else
echo "Пакеты пропущены"
fi
echo "Пакеты установлены"

#Включение apparmor
# systemctl enable apparmor
# systemctl start apparmor

echo "включение power-profiles-daemon.service"
#включение профилей производительности
systemctl unmask power-profiles-daemon.service
systemctl enable power-profiles-daemon.service #Запуск при старте системы
systemctl start power-profiles-daemon.service
echo "status power-profiles-daemon.service"
systemctl status power-profiles-daemon.service #Чтобы убедиться, что сервис запущен

#Добавление правил
# ufw default allow outgoing
# ufw default deny incoming
# ufw enable #Включение фаервола
# echo "ufw status"
# ufw status verbose #Проверка статуса фаервола

systemctl enable fail2ban.service
systemctl start fail2ban.service
echo "status fail2ban:"
systemctl status fail2ban.service
if [ "$y" == "yes" ]; then

echo "Обновление микрокода"
pacman -S --noconfirm amd-ucode
mkinitcpio -P
grub-mkconfig -o /boot/grub/grub.cfg

#Нужно уточнить, нужно ли проводить процедуру после перекомпиляции ядра
else
echo "Микрокод пропущен"
fi
echo "Микрокод обновлен"

#установка yay
if [ "$yay" = "yes" ]; then
#проверяем равно ли значение пременной
{
#Создается subshell; Все команды выполняеются в отдельном процессе; Изменения не влияют на родительский процесс
#sudo -u - это опция конкретной команды sudo, поэтому без нее нельзя запускать
#-u опция, которая указывает от имени какого пользователя необходимо запустить команду
sudo -u "$SUDO_USER" bash -c '
cd ~
git clone https://aur.archlinux.org/yay.git
cd yay
yes | makepkg -si
cd ~
rm -rf yay
yay -Y --gendb --noconfirm && yay -Y --devel --save
yay --version
'
yay -Syu
#SUDO_USER - переменная системы, это пользователь, который вызвал SUDO
#sudo -u "$SUDO_USER" bash -c - вызывает subshell от имени пользователя, который вызвал команду sudo
#Все команды выполняются в отдельном subshell
#Кавычки должны быть одинарные
}
else
echo "Установка yay пропущена"
fi

#Создание конфигурационного файла и редактирование конфига yay

if grep -q "\"$srch_yay_config\".*" "$path_yay_cfg"; then
#Проверяем существование сроки в конфиге
if grep -q "\"$srch_yay_config\": true," "$path_yay_cfg"; then
echo "$srch_yay_config уже true"
#проверяем не является ли false
else
sed -i "s/\"$srch_yay_config\".*/\"$srch_yay_config\": true,/" "$path_yay_cfg"
echo "$srch_yay_config был изменен на true"
#Изменяем на true
fi
else
echo "Строка \"$srch_yay_config\": true, не существует по пути $path_yay_cfg"
if grep -q "{" "$path_yay_cfg"; then
sed -i '/^{/a\
\t"'"$srch_yay_config"'": true,' "$path_yay_cfg"
#\t - символ табуляции
echo "Строка \"$srch_yay_config\": true, была добавлена по пути $path_yay_cfg"
else
echo "Возникла критическая ошибка в редактировании конфигурационного файла yay. Строка \"$srch_yay_config\": true, не была добавлена по пути $path_yay_cfg"
fi
fi

#Установка nohang
if [ "$yay_packages" = "yes" ]; then
sudo -u "$SUDO_USER" bash -c '
cd ~
yay -S --needed  --noconfirm nohang-git aur/minq-ananicy-git aur/stacer-bin aur/xdman aur/firefox-extension-xdman8-browser-monitor-bin extra/irqbalance
yay -Yc --noconfirm'
cp /etc/nohang/nohang-desktop.conf /etc/nohang/nohang.conf
else
echo "yay_packages был пропущен"
fi

systemctl enable --now nohang-desktop
echo "nohang status:"
systemctl status nohang-desktop.service

systemctl enable --now ananicy
echo "ananicy status:"
systemctl status ananicy

systemctl enable --now irqbalance
echo "Статус irqbalance:"
systemctl status irqbalance


#Включение trim
if [ "$trim" = "yes" ]; then
systemctl enable fstrim.timer
fstrim -va
echo "Статус службы fstrim"
systemctl status fstrim.timer
else
echo "trim был пропущен"
fi

if [ "$grub_configurator" = "yes" ]; then
#определяем тип файловой системы для корневого диска

#Создаем переменную с командой, которая ищет строку, где смонтирован корень
fstype_var=$(findmnt -n -o FSTYPE / 2>/dev/null || awk '$2 == "/" {print $3}' /proc/mounts)

#awk - перебирает слова и строки, находит слово type и выводит следующее за ним значение
grub_params="quiet loglevel=0 rd.systemd.show_status=auto rd.udev.log_level=0 splash rootfstype=$fstype_var selinux=0 raid=noautodetect nowatchdog"

#проверяем наличие бэкапа
if [ -f "$grab_conf.original" ]; then
echo "Бэкап grub уже существует"
else
if [ -f "$grab_conf" ]; then
#Создаем бэкап
cp "$grab_conf" "$grab_conf.original"
echo "Был создан бэкап $grab_conf.original"
else
echo "Конфиг grub по пути: $grab_conf не был найден"
fi
fi

#Проверяем наличие строки
if grep -q "^.*$srch_grub_default.*" "$grab_conf"; then

#изменяем строку
sed -i "s/^$srch_grub_default=.*/$srch_grub_default=\"$grub_params\"/" "$grab_conf"

else
echo "$srch_grub_default не был найден по пути $grab_conf. Вставьте строку:\n $srch_grub_default=\"$grub_params\""

fi
#создаем конфиг
grub-mkconfig -o /boot/grub/grub.cfg

else
echo "Конфигурация grub пропущена"
fi


#Включаем gamemode
sudo -u "$user_nosudo" DBUS_SESSION_BUS_ADDRESS="unix:path=$USER_RUNTIME_DIR/bus" XDG_RUNTIME_DIR="$USER_RUNTIME_DIR" systemctl --user enable gamemoded
sudo -u "$user_nosudo" DBUS_SESSION_BUS_ADDRESS="unix:path=$USER_RUNTIME_DIR/bus" XDG_RUNTIME_DIR="$USER_RUNTIME_DIR" systemctl --user start gamemoded
sudo -u "$user_nosudo" DBUS_SESSION_BUS_ADDRESS="unix:path=$USER_RUNTIME_DIR/bus" XDG_RUNTIME_DIR="$USER_RUNTIME_DIR" systemctl --user status gamemoded

#установка reflector
pacman -S --noconfirm --needed reflector
reflector --country 'Russia' --protocol https --latest 20 --sort rate --save /etc/pacman.d/mirrorlist
pacman -Syyu
systemctl enable reflector.service
systemctl start reflector.service
systemctl enable reflector.timer

pacman -Scc --noconfirm

# Установка flatpak
sudo pacman -S flatpak flatpak-kcm flatpak-xdg-utils
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo


#возможно стоит добавить выбор локалей
echo "Если вас не устраивает устанволенная локаль, то прмините команды
sudo nano /etc/locale.gen          # Редактирование локалей
sudo locale-gen                    # Генерация локалей"


1.2. Оптимизация mkinitcpio
initramfs (первоначальный RAM-диск) загружается перед основной системой. Его можно и нужно оптимизировать.
Использовать сжатие lz4 или zstd: Они намного быстрее, чем стандартный gzip, при распаковке во время загрузки. Это один из самых простых и эффективных способов ускорить загрузку. В файле /etc/mkinitcpio.conf измени строку:
Generated code
COMPRESSION="zstd" 
```*   **Уменьшить количество хуков**: В строке `HOOKS=(...)` в том же файле оставь только то, что тебе действительно нужно. Например, если у тебя нет LVM или шифрования, хуки `lvm2` и `encrypt` не нужны.
Use code with caution.
1.3. Оптимизация Systemd-boot или другого загрузчика
Уменьшить таймаут: В файле loader.conf (для systemd-boot) или grub.cfg установи таймаут выбора ОС на 0 или 1 секунду, если тебе не нужно меню загрузки.
2. Оптимизация Файловой Системы и Дисковых Операций
2.1. Выбор и настройка файловой системы
Btrfs: Современная и быстрая ФС. Позволяет использовать прозрачное сжатие на лету (compress=zstd), что не только экономит место, но и может ускорить чтение/запись на медленных дисках (особенно HDD), так как сжатые данные занимают меньше места и быстрее считываются.
Опции монтирования в /etc/fstab: rw,noatime,compress=zstd,space_cache=v2,discard=async
F2FS: Оптимизирована специально для флеш-памяти (SSD, NVMe). Часто показывает лучшие результаты в тестах производительности на SSD.
2.2. Preloading (Предварительная загрузка)
Сервисы, которые анализируют часто запускаемые приложения и заранее подгружают их библиотеки в ОЗУ.
preload: Старый, но все еще рабочий демон.
prelockd: Более современный и интеллектуальный аналог, разработанный создателем nohang. Он анализирует использование и "закрепляет" (mlock) нужные файлы в памяти.
systemd-readahead (устарел, но концепция важна): Раньше systemd пытался делать это автоматически. Сейчас эта функциональность удалена, но идея остается актуальной.
4.1. Использование альтернативных аллокаторов памяти
Стандартный аллокатор памяти в Linux (glibc malloc) — это универсальное решение. Специализированные аллокаторы могут быть быстрее в многопоточных приложениях (игры, компиляция).
mimalloc или jemalloc: Могут быть использованы для всей системы или для отдельных приложений через LD_PRELOAD. Это может дать заметный прирост производительности в некоторых сценариях.
Generated bash
Запуск приложения с mimalloc
LD_PRELOAD="/usr/lib/libmimalloc.so" steam
Use code with caution.
Bash
4.2. Оптимизация makepkg для сборки из AUR
Ты уже используешь yay, который под капотом вызывает makepkg. Его можно настроить.
В /etc/makepkg.conf:
CFLAGS и CXXFLAGS: Добавь -march=native -O2 (или -O3, но это может быть менее стабильно) для оптимизации сборки под твой CPU.
MAKEFLAGS: Установи -j$(nproc) для использования всех ядер процессора при компиляции. Yay часто делает это автоматически, но проверить стоит.
4.3. Сетевые оптимизации (sysctl)
Для уменьшения задержек в онлайн-играх и улучшения отзывчивости сети можно добавить в твой 99-custom.conf:
Generated code
# Уменьшить задержку TCP
net.ipv4.tcp_low_latency = 1
# Включить TCP Fast Open
net.ipv4.tcp_fastopen = 3


#Установка zsh
# Обновляемся
sudo pacman -Syu
# установка всех пакетов
sudo pacman -S zsh zsh-completions git curl fzf powerline-fonts nerd-fonts-hack
chsh -s $(which zsh)
# chsh — это команда, которая меняет оболочку входа пользователя в систему
echo $SHELL
# Установка фреймворка Oh My Zsh
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
# --unattended чтобы скрипт не задавал лишних вопросов и не пытался сменить оболочку еще раз.

# Установка шрифтов
sudo pacman -S powerline-fonts
# Редактирование файла
nano ~/.zshrc
# Настройка темы
ZSH_THEME="agnoster"

# Активация плагинов
plugins=(
 # Основные плагины
  git
  sudo
  z
  fzf

  # Улучшения Shell
  colored-man-pages
  zsh-autosuggestions
  zsh-syntax-highlighting
  history-substring-search
  autocorrect

  # Системные и для разработки
  archlinux
  systemd
  docker
  docker-compose

  # Для экосистемы Kotlin
  sdkman
  kotlin
  gradle
)
# git - Алиасы и удобные функции для работы с Git
# archlinux - Короткие псевдонимы для команд `pacman` (например, `pacs` вместо `pacman -S`).
# colored-man-pages - Делает страницы `man` цветными и более читаемыми.
# z - Просто пишите `z часть_имени_папки`, и он перенесет вас в самый часто посещаемый каталог с таким названием
# fzf - Интеграция нечеткого поиска. Теперь **`Ctrl+R`** вызовет интерактивный поиск по истории команд, а **`Ctrl+T`** — поиск файлов в текущем каталоге.
# zsh-autosuggestions - Подсказки команд на основе истории и автодополнения.
# zsh-syntax-highlighting - Подсветка синтаксиса команд в термин
# history-substring-search: Этот плагин кардинально улучшает поиск по истории. Вы начинаете вводить любую часть команды (не обязательно с начала), а затем нажимаете клавиши Вверх/Вниз, чтобы переключаться между всеми совпадениями из вашей истории
# autocorrect: Исправляет незначительные опечатки в командах.
# systemd: Очень полезно для Arch Linux. Добавляет короткие псевдонимы для управления службами systemd. Например, scs apache вместо systemctl status apache
# sdkman - менеджер версий для множества SDK (Software Development Kit) для JVM и не только
# kotlin: Добавляет автодополнение для команд компилятора kotlin и kotlinc
# gradle  Он обеспечивает автодополнение для задач Gradle. Вы можете написать ./gradlew bui и нажать Tab, чтобы он дополнил до build.

# Установка внешних плагинов
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
git clone https://github.com/zsh-users/history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/history-substring-search


# Привязка клавиш для history-substring-search. Чтобы history-substring-search заработал на стрелках Вверх/Вниз, добавьте эти строки в конец вашего файла ~/.zshrc
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

source ~/.zshrc

# Установка SDKMAN
curl -s "https://get.sdkman.io" | bash
source "$HOME/.sdkman/bin/sdkman-init.sh"
# Устанавливаем последнюю версию Java (необходима для Kotlin)
sdk install java

# Устанавливаем последнюю версию Kotlin
sdk install kotlin

# Устанавливаем последнюю версию Gradle
sdk install gradle










